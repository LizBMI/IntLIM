---
title: "Creating Breast Cancer Files for IntLIM Analysis"
author: "Jalal K. Siddiqui, PhD"
date: "7/23/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction/Getting Started

This vignette describes how a Metabolon file and file consisting of probe gene expression downloadable from GEO (Accession Number:  GSE37751) was converted into a series of files that could be imported into and analyzed via IntLIM.  The probe data is contained in a file known as geneCore.csv included in this folder.  annotation.csv contains the annotation data that contains the genes symbols corresponding to different probes.  The Metabolon data is contained in the metabolon.data.xls file.  

Prior to running this vignette, it is necessary to download readxl package from Cran (https://cran.r-project.org/web/packages/readxl/index.html).  One can do that by typing install.packages("readxl").  

```{r}
rm(list = ls())
library(readxl)

```

## Importing in Gene Expression Data

The first steps consist of importing in gene expression and annotation data as done below.  geneData is the initial object consiting of imported gene data.  feature.annotation contains the annotation data.  The probe.id vector contains the feature.annotation probe number with an X prefixed to correspond to the gene expression data.  This is shown to be identical with the colume names of the geneData object.  

```{r}
## Import in gene expression data
## geneData is the original imported data file
geneData <- read.csv(file = 'geneCore.csv', row.names = 1)
## feature.annotation is the original annotation file
feature.annotation <- read.csv(file = 'annotation.csv')
## an X is attached to the probe ID
probe.id <- unlist(lapply(1:33297, function(x){return(paste('X', as.character(feature.annotation[x, 1]), sep = ""))}))
identical(probe.id, colnames(geneData))
```

From the annotation objects we create the fData.orig object which is the start of the featureData file.  

```{r}
fData.orig <- data.frame(probe.id, 'genesymbols' = unlist(lapply(as.character(feature.annotation$genesymbols), trimws)))
rownames(fData.orig) <- fData.orig$probe.id
```

Some of the probes correspond no gene symbols.  We remove those probes from the analysis.  

```{r}
## transpose of geneData data frame
geneData.t <- t(geneData)
no.na.vector <- which(is.na(feature.annotation$genesymbols) == FALSE)
geneData.t.noNA <- geneData.t[no.na.vector,]
fData.orig.noNA <- fData.orig[no.na.vector,]
identical(rownames(geneData.t.noNA), as.character(fData.orig.noNA$probe.id))
```

The next set of code identifies and removes duplicate probes.  

```{r}
unique.gene.symbols <- unique(fData.orig.noNA$genesymbols)
## Calculate mean probe expression of each row.  
geneData.t.noNA.max <- apply(geneData.t.noNA, 1, mean)
length(geneData.t.noNA.max)
## Create data frame with fData and maximum expression information
max.info.geneExp <- data.frame(fData.orig.noNA, 'maxExp' =geneData.t.noNA.max)
rownames(max.info.geneExp) <- as.character(max.info.geneExp$probe.id)
## function to determine maximum probe index for a given gene symbol

max.probe.given.gs <- function(gs.name){
    gData.list.gs <- max.info.geneExp[which(max.info.geneExp$genesymbols == gs.name),]
    max.gs <- max(gData.list.gs$maxExp)
    max.probe.given.gs.vector <- gData.list.gs[which(gData.list.gs$maxExp == max.gs),'probe.id']
    max.probe.given.gs <- max.probe.given.gs.vector[1]
    return(as.character(max.probe.given.gs))
}

keep.probes <- unlist(lapply(unique.gene.symbols, max.probe.given.gs))
geneData.removeDup <- geneData.t.noNA[keep.probes,]
fData.orig.removeDup <- fData.orig.noNA[keep.probes,]

rownames(fData.orig.removeDup) <- c()

geneData.final <- geneData.removeDup
rownames(geneData.final) <- fData.orig.removeDup$genesymbols
zeros.vector <- rep(0, length(unique.gene.symbols))
fData.final <- data.frame('name' = fData.orig.removeDup$genesymbols, 
                          'id' = fData.orig.removeDup$genesymbols, 
                          'start' = zeros.vector, 'end' = zeros.vector, 
                          'chromosome' = zeros.vector)
rownames(fData.final) <- fData.final$id


```

We will export the gene expression files later.  

## Importing in Metabolomics Data

The next step is to import in metabolomics data from Metabolon.  A function has been written as below.  This file outputs a list with phenotypic data, feature data, and metabolomics abundances data.  

```{r}
## Extracting the Metabolon file

getMetabolon <- function(path, logmetab = FALSE, logbase = 2, phen.id.label = 'LHC', feature.id.label = 'BIOCHEMICAL'){
    #	path <- "metabolonfile.xls"
    
    #sampimp contains the excel read from the file path
    #Takes from the second sheet of the excel file (the imputed data)
    sampimp <- read_excel(path, sheet = 2, col_names = FALSE, col_types = NULL, na = "",skip = 0)
    sampimp <- as.data.frame(sampimp)
    #collect dimensions of the sampimp object
    dimSamp <- dim(sampimp)
    rows.samp <- dimSamp[1]
    cols.samp <- dimSamp[2]
    
    #look for the center cell with the HMDB_ID label
    #This will be pending discussion with a Metabolon representative
    #This is referred to as the 'index'
    get.index.col <- grep("HMDB_ID", sampimp)
    get.index.row <- grep("HMDB_ID", sampimp[,get.index.col])
    
    #index is actually HMDB_ID + another marker.  We should isolate that marker
    index.name.step1 <- unlist(strsplit(sampimp[get.index.row,get.index.col], "HMDB_ID"))
    index.name <- trimws(index.name.step1)
    
    ##get phenData
    #We will extract the phenoData from the file that we have extracted
    
    #pData contains the phenoData from the file
    pData <- sampimp[1:get.index.row, (get.index.col + 1):cols.samp]
    
    #the index column rows forms the row names for the pData
    rownames(pData) <- sampimp[1:get.index.row, get.index.col]
    #index.name is the name of the last row
    rownames(pData)[get.index.row] <- index.name
    
    #finds an entry in the pData rownames that contains an entry of 'id'
    #Will be used to set the id vector for the phenoData
    id.row.index <- which(rownames(pData) == phen.id.label)
    #print(phen.id.label)
    id <- pData[id.row.index,]
    #print(id)
    id <- as.integer(id)
    id <- as.character(id)
    
    #creates a pData data frame that contains pData + an id vector
    p.id <- id
    colnames(pData) <- id
    pData <- data.frame(t(pData))
    pData <- data.frame(id,pData)
    
    ##get featureData
    #We will extract the featureData from the file that we have extracted
    
    #fData contains the featureData from the file
    fData <- sampimp[(get.index.row+1):rows.samp,1:get.index.col]
    
    #The index row forms the column names for the fData
    col.fData <- dim(fData)[2]
    colnames(fData) <- sampimp[get.index.row, 1:get.index.col]
    #"HMDB_ID" is the name of the last column of featureData
    colnames(fData)[col.fData] <- "HMDB_ID"
    
    #METABOLON_ID is seen as the column for metabolite ids
    id.col.index <- which(colnames(fData) == feature.id.label)
    id <- fData[,id.col.index]
    #id <- as.integer(id)
    id <- as.character(id)
    f.id <- id
    rownames(fData) <- id
    
    #new data frame is created for the feature data
    fData <- data.frame(fData)
    fData <- data.frame(id,fData)
    
    #parse out the metabolite data matrix into metabData and convert into a matrix format
    metabData <- sampimp[(get.index.row+1):rows.samp, (get.index.col + 1):cols.samp]
    metabData <- as.matrix(metabData)
    orig.metabData <- metabData
    #Convert into a numeric matrix
    dim.md <- dim(metabData)
    metabData.number <- as.numeric(metabData)
    metabData <- matrix(metabData.number, dim.md[1], dim.md[2])
    
    #rownames and colnames of metabData are set as ids for phenoData and featureData
    colnames(metabData) <- p.id
    rownames(metabData) <- f.id
    
    
    if (logmetab == TRUE){
        metabData <- log(metabData,logbase)
    }
    
    
    getMetabolon <- list(metabData, pData, fData, orig.metabData)
    
    return(getMetabolon)
    
}
```

The following code imports in the Metabolon file into 3 objects for abundance data, pData, and fData.  'LHC-; is appended to the names of the samples to correspond to the gene expression files.  

```{r}
list.mb <- getMetabolon('metabolon.bc.data.xls', logmetab = TRUE, logbase = 2)

metabData <- list.mb[[1]]
pData.metab <- list.mb[[2]]
fData.metab <- list.mb[[3]]

lhc.names <- rownames(pData.metab)
len_lhc <- length(lhc.names)
lhc.newnames <- c()
lhc.newnames <- unlist(lapply(lhc.names, function(x){return(paste('LHC', x, sep = ''))}))

colnames(metabData) <- lhc.newnames
rownames(pData.metab) <- lhc.newnames
pData.metab$LHC <- lhc.newnames
pData.metab$id <- lhc.newnames

```

## Exporting Objects to files

The final step is exporting the objects to respective files.  We need to arrange the patient LHC IDs in order for the gene expression data.  We find more patient samples in metabolite data vs gene expression data.  Lets get the intersect of samples in both gene and metabolite data. From setdiff we find that the metabolite data set contains all patient samples.  Gene data is missing some samples.   

```{r}
dim(geneData.final)
dim(metabData)
setdiff(colnames(metabData), colnames(geneData.final))
setdiff(colnames(geneData.final), colnames(metabData))
intersect.samples <- intersect(colnames(metabData), colnames(geneData.final))
```

The next step is revising the gene expression matrix

```{r}
geneData.final.output <- geneData.final[,intersect.samples]
```

The files are output as follows.  

```{r}
write.csv(geneData.final.output, 'geneData.csv')
write.csv(fData.final, 'fData.gene.csv', row.names = FALSE)
write.csv(pData.metab, "pData.csv", row.names = FALSE)
write.csv(metabData, "metabData.csv")
write.csv(fData.metab, "fData.metab.csv", row.names = FALSE)
```

